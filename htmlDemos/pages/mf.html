<!DOCTYPE html>
<html lang="zh">
<head>
	<meta charset="utf-8">
	<link href="mofang/styles.css" rel="stylesheet">
</head>
<body id="page-top" data-spy="scroll" data-target=".navbar-custom" class="sidebaros">
	<div class="sections">
		<section id="solutionstep1" class="home-section text-center">
			<div class="heading-about">
				<div class="container">
				<div class="row">
					<div class="col-lg-8 col-lg-offset-2">
						<div class="section-heading">
							<h2>解决白色边缘</h2>
						</div>
					</div>
				</div>
				</div>
			</div>
			<div class="container">
				<div class="row">
					<div class="col-xs-12 col-sm-12 col-md-12">
						<div class="service-box">
							<p>我们已经知道中心块是固定的，并且它们定义每个面部的颜色。这就是为什么我们必须解决白色边缘块，注意中间。<p>
							<p>解决白色边缘是直观且相当容易的，因为没有很多您必须注意的已排列组件。在大多数情况下，您只需简单地旋转它至需要到的位置便可。</p>
							<p>这里有几个需要一些额外移动的例子。</p>
						</div>
					</div>
				</div>
				<div class="row">
					<div class="col-xs-12 col-sm-4 col-md-4">
						<div class="service-box">
							<div class="roofpig" data-config="alg=U' R' U F'|colored=U*/e U D R L F B|speed=1000|flags=showalg|hover=1|colors=U:w F:o R:g B:r L:b D:y"></div>
							<div class="service-desc">
								<h5><span class="alg">U' R' U F'</span></h5>
								<p>当一面在右点（FU边缘）时，但其方向是错误的，应使用此类短算法。</p>
							</div>
						</div>
					</div>
					<div class="col-xs-12 col-sm-4 col-md-4">
						<div class="service-box">
							<div class="roofpig" data-config="alg=F' R' D' R F2|colored=U*/e U D R L F B|speed=1000|flags=showalg|hover=1|colors=U:w F:o R:g B:r L:b D:y"></div>
							<div class="service-desc">
								<h5><span class="alg">F' R' D' R F2</span></h5>
								<p>当您因为它会定向错误，而不能简单地只是把前沿转到它的正确位置，可以使用这个方法。</p>
							</div>
						</div>
					</div>
					<div class="col-xs-12 col-sm-4 col-md-4">
						<div class="service-box">
							<div class="roofpig" data-config="alg=R' D' R F2|colored=U*/e U D R L F B|speed=1000|flags=showalg|hover=1|colors=U:w F:o R:g B:r L:b D:y"></div>
							<div class="service-desc">
								<h5><span class="alg">R' D' R F2</span></h5>
								<p>当它在错误的中间层面时，可以使用这个方法解决白色边缘。</p>
							</div>
						</div>
					</div>
				</div>
				<div class="row">
					<div class="col-lg-8 col-lg-offset-2">
						<div class="wow bounceInDown" data-wow-delay="0.6s">
							<div class="scrollDownGT rotate90">&raquo;</div>
						</div>
					</div>
				</div>
			</div>
		</section>
		<section id="solutionstep2" class="home-section text-center">
			<div class="heading-about">
				<div class="container">
				<div class="row">
					<div class="col-lg-8 col-lg-offset-2">
						<div class="section-heading">
							<h2>解决白色角落</h2>
							<p><strong>现在白色边缘已经解决了，我们必须修复白色的角落来完成第一面。</strong> </p>
						</div>
					</div>
				</div>
				</div>
			</div>
			<div class="container">
				<div class="row">
					<div class="col-xs-12 col-sm-6 col-md-6">
						<div class="service-box">
							<p><img src="/img/solution-2-solved-first-white-face.svg" class="cubeImage" alt="solved white face corners" /></p>
							<p>当我们完成这一步时，魔方应该相似这个样子。</p>
							<p>这是另一简单步骤，您不应死记硬背这些算法，只需按照您的直觉移动。 </p>
						</div>
					</div>
					<div class="col-xs-12 col-sm-6 col-md-6">
						<div class="service-box">
							<p><img src="/img/solution-2-solve-white-corners-rdrd.svg" class="cubeImage" alt="solved white face corners" /></p>
							<p>如果您在解决白色角时遇到困难，这里有一个简单的窍门。您只需要记住一个简短的算法，并重复，直至该面完成排列：</p>
							<h5><span class="alg">R' D' R D</span></h5>
							<p>将角放置在它所属地方的下方（前右上角），并重复上述算法，直至白色角进入正确的定向。该算法在标有黑色的点之间来回发送每个面，并总是改变方向。</p>
						</div>
					</div>
				</div>
				<div class="row">
					<div class="col-xs-12 col-sm-12 col-md-12">
						<div class="service-box">
							<p><strong>R' D' R D</strong> 技巧总是可行的，但需要太多不必要的步骤，这里有较短的算法：</p>
						</div>
					</div>
				</div>
				<div class="row">
					<div class="col-xs-12 col-sm-6 col-md-6">
						<div class="roofpig" data-config="alg=F D F'|colored=U* D R L F B|speed=1000|flags=showalg|hover=1|colors=U:w F:o R:g B:r L:b D:y"></div>
						<div class="service-desc">
							<h5><span class="alg">F D F'</span></h5>
						</div>
					</div>
					<div class="col-xs-12 col-sm-6 col-md-6">
						<div class="roofpig" data-config="alg=R' D2 R D R' D' R|colored=U* D R L F B|speed=1000|flags=showalg|hover=1|colors=U:w F:o R:g B:r L:b D:y"></div>
						<div class="service-desc">
							<h5><span class="alg">R' D2 R D R' D' R</span></h5>
						</div>
					</div>
				</div>
				<div class="row">
					<div class="col-lg-8 col-lg-offset-2">
						<div class="wow bounceInDown" data-wow-delay="0.6s">
							<div class="scrollDownGT rotate90">&raquo;</div>
						</div>
					</div>
				</div>
			</div>
		</section>
		<section id="solutionstep3" class="home-section text-center">
			<div class="heading-about">
				<div class="container">
				<div class="row">
					<div class="col-lg-8 col-lg-offset-2">
						<div class="section-heading">
							<h2>中间层</h2>
							<p><strong>现在我们已经完成了白色的一面。让我们把立方体倒置，因为我们不再需要查看已经完成的一面。</strong> </p>
							<p>解决方案非常简单且直观，直至这一点，但大多数人会在这里陷入困境，因为用于解决第二层的算法需要预见太多的步骤。</p>
							<p>我们必须学习两个彼此对称的算法。右算法将边缘一侧从前上位置发送至前右位置，而左算法将该侧发送到左前方。</p>
							<p>&nbsp;</p>
						</div>
					</div>
				</div>
				</div>
			</div>
			<div class="container">
				<div class="row">
					<div class="col-xs-12 col-sm-6 col-md-offset-1 col-md-5">
						<div class="service-box">
							<h3>左</h3>
							<div class="roofpig" data-config="alg=U' L' U L U F U' F'|colored=U*- U|speed=1000|hover=1|tweaks=X:FL|flags=showalg|colors=U:y F:g R:o B:b L:r D:w"></div>
							<h5><span class="alg">U' L' U L U F U' F'</span></h5>
						</div>
					</div>
					<div class="col-xs-12 col-sm-6 col-md-5">
						<div class="service-box">
							<h3>右</h3>
							<div class="roofpig" data-config="alg=U R U' R' U' F' U F|colored=U*- U|tweaks=X:FR|hover=1|speed=1000|flags=showalg|colors=U:y F:g R:o B:b L:r D:w"></div>
							<h5><span class="alg">U R U' R' U' F' U F</span></h5>
						</div>
					</div>
				</div>
				<div class="row">
					<div class="col-xs-12 col-sm-12 col-md-12">
						<div class="service-box">
							<p>当没有侧面插入中间层，您必须执行算法两次才能在第一步中弹出该侧。</p>
							<p><img src="/img/middle-layer-orient.svg" class="cubeImage" alt="solution f2l middle layer" /></p>
							<h5><span class="alg">U R U' R' U' F' U F</span> <span class="algSeparator">-</span> <span class="alg">U2</span> <span class="algSeparator">-</span> <span class="alg">U R U' R' U' F' U F</span></h5>
						</div>
					</div>
				</div>
				<div class="row">
					<div class="col-lg-8 col-lg-offset-2">
						<div class="wow bounceInDown" data-wow-delay="0.6s">
							<div class="scrollDownGT rotate90">&raquo;</div>
						</div>
					</div>
				</div>
			</div>
		</section>
		<section id="solutionstep4" class="home-section text-center">
			<div class="heading-about">
				<div class="container">
				<div class="row">
					<div class="col-lg-10 col-lg-offset-1">
						<div class="section-heading">
							<h2>顶部十字</h2>
							<p><strong>在第四步中，我们想在立方体的顶部形成一个黄色的十字。如果侧边颜色不符合侧边中心颜色，请不要担心，因为我们将在下一步中将这些侧面发送到它们的最终位置。</strong> </p>
							<p>&nbsp;</p>
						</div>
					</div>
				</div>
				</div>
			</div>
			<div class="container">
				<div class="row">
					<div class="col-xs-12 col-md-offset-1 col-sm-12 col-md-10">
						<div class="service-box">
							<p class="crossImageChain"><img src="/img/yellow-cross-dot.svg" alt="top yellow dot" />&raquo;<img src="/img/top-l-shape.svg" alt="lshape" />&raquo;<img src="/img/yellow-line.svg" alt="horizontal line" />&raquo;<img src="/img/yellow-top-cross.svg" alt="yellow cross done" /></p>
							<p>在该步骤中，当所有其它边缘完成时，除了黄色，您可以在您的魔方顶部获取这些模式。使用算法转换到下一个状态，直到到达十字架。</p>
							<h5><span class="alg">F R U R' U' F'</span></h5>
							<ul class="caseList">
								<li><strong>点</strong> &ndash; 当所有顶部边缘定向错误时，我们必须应用公式三次，在顶面，只有中心侧是黄色。在第一阶段之后，确保你重新调整手中的立方体，因为“L”形将是颠倒的， </li>
								<li><strong>"L"-字形</strong> &ndash; 您距离目标有两个算法的距离确保背面和左边缘是黄色的，如图所示。。<br /><em>(有一个快捷方式，在一个步骤中从“L”形形状跳到十字形，降低解决方案的时间: <strong>F&nbsp;U&nbsp;R&nbsp;U'&nbsp;R'&nbsp;F'</strong>).</em></li>
								<li><strong>行</strong> &ndash; 只执行一次算法，您便完成了</li>
								<li><strong>十字</strong> &ndash; 十字是完整的，您可以进入一个新水平！</li>
							</ul>
							<p>&nbsp;</p>
						</div>
					</div>
				</div>
				<div class="row">
					<div class="col-lg-8 col-lg-offset-2">
						<div class="wow bounceInDown" data-wow-delay="0.6s">
							<div class="scrollDownGT rotate90">&raquo;</div>
						</div>
					</div>
				</div>
			</div>
		</section>
		<section id="solutionstep5" class="home-section text-center">
			<div class="heading-about">
				<div class="container">
				<div class="row">
					<div class="col-lg-8 col-lg-offset-2">
						<div class="section-heading">
							<h2>交换最后一层边</h2>
							<p><strong>在顶部，我们有十字，但黄色边缘与边颜色不匹配。我们需要把它们放在他们的最终目的地。</strong> </p>
							<p>为了解决这一问题，我们使用一种算法，交换前上和左上相邻边缘。在某些情况下，两个相对的部分必须交换，这需要在两个步骤中完成。</p>
							<h5><span class="alg">R U R' U R U2 R' U</span></h5>
							<div class="roofpig" data-config="alg=R U R' U R U2 R' U|colored=D* F R U B L FL FR RU UB UL UR UL BL BR FU|tweaks=X:UF X:UL|speed=1000|flags=showalg|hover=1|colors=U:y F:g R:o B:b L:r D:w"></div>
							<p>在某些情况下，两个相对的部分必须交换，这需要在两个步骤中完成。<br />执行一次算法，然后旋转立方体，以确保您在第二轮中更改为正确的部分。 </p>
							<p>&nbsp;</p>
						</div>
					</div>
				</div>
				</div>
			</div>
			<div class="container">
				<div class="row">
					<div class="col-lg-8 col-lg-offset-2">
						<div class="wow bounceInDown" data-wow-delay="0.6s">
							<div class="scrollDownGT rotate90">&raquo;</div>
						</div>
					</div>
				</div>
			</div>
		</section>
		<section id="solutionstep6" class="home-section text-center">
			<div class="heading-about">
				<div class="container">
				<div class="row">
					<div class="col-xs-12">
						<div class="section-heading">
							<h2>位置在最后一个层角</h2>
							<p><strong>我们马上就要完成我们的 Rubik魔方了。只剩下黄色的角落，我们将分两个步骤进行。首先，我们必须以定位它们，在下一步骤中定向它们。</strong></p>
							<p><img src="/img/cycle-yellow-corners.svg" class="cubeImage" alt="rubiks cube solution tutorial" /></p>
							<h5><span class="alg">U R U' L' U R' U' L</span></h5>
							<p>此算法循环上面图像上标有数字的角，及标有“OK”的前右上角将保留在原位。</p>
							<div class="roofpig" data-config="alg=U R U' L' U R' U' L|setupmoves=R' D' R D R' D' R D R' D' R D R' D' R D U R' D' R D R' D' R D U R' D' R D R' D' R D R' D' R D R' D' R D U R' D' R D R' D' R D U|tweaks=X:UFR|speed=1000|flags=showalg|hover=1|colors=U:y F:g R:o B:b L:r D:w"></div>
							<p>当您到达这一点，并在解决方案中寻找一个角落，即在正确的地方。如果你可以找到一个，然后重新定位您手中的魔方，那么便会在准确的位置上，并执行公事。在某些情况下，你必须使用它两次。</p>
							<p>如果在正确的位置没有黄色的角，然后通过算法来识别它们，然后再看看，因为这一次必须有一个。 </p>
							<p>一个有趣的事实是，在这个步骤中，右边点的片段数量只能是0,1或4。 </p>
						</div>
					</div>
				</div>
				</div>
			</div>
			<div class="container">
				<div class="row">
					<div class="col-lg-8 col-lg-offset-2">
						<div class="wow bounceInDown" data-wow-delay="0.6s">
							<div class="scrollDownGT rotate90">&raquo;</div>
						</div>
					</div>
				</div>
			</div>
		</section>
		<section id="solutionstep7" class="home-section text-center">
			<div class="heading-about">
				<div class="container">
				<div class="row">
					<div class="col-lg-10 col-lg-offset-1">
						<div class="section-heading">
							<h2>定向最后一个角</h2>
							<p><strong>在最后一步中的每一块应该在其正确位置上，但黄色的角落是错误的。为了完成我们的立方体，我们将使用相同的算法，我们用来解决第一层角：</strong> </p>
							<h5><span class="alg">R' D' R D</span></h5>
						</div>
					</div>
				</div>
				</div>
			</div>
			<div class="container">
				<div class="row">
					<div class="col-xs-12 col-sm-12 col-md-8">
						<div class="service-box">
							<p><img src="/img/orient-yellow-corners.svg" class="cubeImage" alt="solution of rubiks cube fix corners" /></p>
							<p>首先在突出显示的右前方点，拿着你的手有一个不对准的黄色角落的立方体（见图）。重复<strong>R'&nbsp;D'&nbsp;R&nbsp;D</strong>算法，直到这一块在它的地方与黄色贴纸。</p>
							<p><strong>只将一面向上转动，</strong>将另一个错误的黄色拐角移到突出显示的点，并重复<strong>R'&nbsp;D'&nbsp;R&nbsp;D</strong>算法，直到这个黄色面被解决。</p>
							<p>移动其他未对齐的黄色边角，一个一个到标记的点，并做公式，直到所有的黄色角落都被解决。</p>
							<p>在移动之间，拼图可能看起来很乱，但不要担心，因为  当所有黄色角落正确定向时，一切都会是固定的。</p>
						</div>
					</div>
					<div class="col-xs-12 col-sm-12 col-md-4">
						<div class="service-box">
							<p>下面的例子演示时，即当所有角落的方向错误时。它将黄色角逐个移动到前右空间，并执行<strong>(R'&nbsp;D'&nbsp;R&nbsp;D)</strong> ，直到它们都被固定。</p>
							<p>按播放按钮查看动画：</p>
							<div class="roofpig" data-config="alg=R' D' R D R' D' R D R' D' R D R' D' R D U R' D' R D R' D' R D U R' D' R D R' D' R D R' D' R D R' D' R D U R' D' R D R' D' R D U|speed=600|flags=showalg|hover=1|colors=U:y F:g R:o B:b L:r D:w"></div>
						</div>
					</div>
				</div>
				<div class="row">
					<div class="col-lg-8 col-lg-offset-2">
						<div class="wow bounceInDown" data-wow-delay="0.6s">
							<div class="scrollDownGT rotate90">&raquo;</div>
						</div>
					</div>
				</div>
			</div>
		</section>
	</div>
	<script src="mofang/scripts.js"></script>
</body>
</html>