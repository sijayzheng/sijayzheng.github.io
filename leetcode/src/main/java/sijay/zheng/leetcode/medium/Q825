package sijay.zheng.leetcode.medium;
/**
 题目825：数组元素的最小非零乘积
<p>给你一个正整数<code>p</code>。你有一个下标从 <strong>1</strong>开始的数组<code>nums</code>，这个数组包含范围<code>[1, 2<sup>p</sup> - 1]</code>内所有整数的二进制形式（两端都 <strong>包含</strong>）。你可以进行以下操作 <strong>任意</strong>次：</p>

<ul>
	<li>从 <code>nums</code>中选择两个元素<code>x</code>和<code>y</code> 。</li>
	<li>选择 <code>x</code>中的一位与 <code>y</code>对应位置的位交换。对应位置指的是两个整数 <strong>相同位置</strong>的二进制位。</li>
</ul>

<p>比方说，如果<code>x = 11<em><strong>0</strong></em>1</code>且<code>y = 00<em><strong>1</strong></em>1</code>，交换右边数起第 <code>2</code>位后，我们得到<code>x = 11<em><strong>1</strong></em>1</code> 和<code>y = 00<em><strong>0</strong></em>1</code>。</p>

<p>请你算出进行以上操作 <strong>任意次</strong>以后，<code>nums</code>能得到的 <strong>最小非零</strong>乘积。将乘积对<em></em><code>10<sup>9</sup> + 7</code><strong>取余</strong> 后返回。</p>

<p><strong>注意：</strong>答案应为取余 <strong>之前</strong>的最小值。</p>

<p></p>

<p><strong>示例 1：</strong></p>

<pre>
<b>输入：</b>p = 1
<b>输出：</b>1
<b>解释：</b>nums = [1] 。
只有一个元素，所以乘积为该元素。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<b>输入：</b>p = 2
<b>输出：</b>6
<b>解释：</b>nums = [01, 10, 11] 。
所有交换要么使乘积变为 0 ，要么乘积与初始乘积相同。
所以，数组乘积 1 * 2 * 3 = 6 已经是最小值。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<b>输入：</b>p = 3
<b>输出：</b>1512
<b>解释：</b>nums = [001, 010, 011, 100, 101, 110, 111]
- 第一次操作中，我们交换第二个和第五个元素最左边的数位。
    - 结果数组为 [001, <em><strong>1</strong></em>10, 011, 100, <em><strong>0</strong></em>01, 110, 111] 。
- 第二次操作中，我们交换第三个和第四个元素中间的数位。
    - 结果数组为 [001, 110, 0<em><strong>0</strong></em>1, 1<em><strong>1</strong></em>0, 001, 110, 111] 。
数组乘积 1 * 6 * 1 * 6 * 1 * 6 * 7 = 1512 是最小乘积。
</pre>

<p></p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= p &lt;= 60</code></li>
</ul>

*/
 class Q825 {public static void main(String[] args) {Solution solution=new Solution();}
static class Solution {
    public int minNonZeroProduct(int p) {

    }
}
}
