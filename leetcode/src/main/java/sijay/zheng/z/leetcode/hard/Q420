package sijay.zheng.z.leetcode.hard;
/**
 题目420：删除操作后的最大子段和
<p>给你两个下标从 <strong>0</strong>开始的整数数组<code>nums</code> 和<code>removeQueries</code>，两者长度都为<code>n</code>。对于第<code>i</code>个查询，<code>nums</code>中位于下标<code>removeQueries[i]</code>处的元素被删除，将 <code>nums</code>分割成更小的子段。</p>

<p>一个 <strong>子段</strong>是 <code>nums</code>中连续 <strong>正</strong>整数形成的序列。<strong>子段和</strong>是子段中所有元素的和。</p>

<p>请你返回一个长度为 <code>n</code>的整数数组<em></em><code>answer</code>，其中<em></em><code>answer[i]</code>是第<code>i</code>次删除操作以后的<strong>最大</strong>子段和。</p>

<p><strong>注意：</strong>一个下标至多只会被删除一次。</p>

<p></p>

<p><strong>示例 1：</strong></p>

<pre><b>输入：</b>nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]
<b>输出：</b>[14,7,2,2,0]
<b>解释：</b>用 0 表示被删除的元素，答案如下所示：
查询 1 ：删除第 0 个元素，nums 变成 [0,2,5,6,1] ，最大子段和为子段 [2,5,6,1] 的和 14 。
查询 2 ：删除第 3 个元素，nums 变成 [0,2,5,0,1] ，最大子段和为子段 [2,5] 的和 7 。
查询 3 ：删除第 2 个元素，nums 变成 [0,2,0,0,1] ，最大子段和为子段 [2] 的和 2 。
查询 4 ：删除第 4 个元素，nums 变成 [0,2,0,0,0] ，最大子段和为子段 [2] 的和 2 。
查询 5 ：删除第 1 个元素，nums 变成 [0,0,0,0,0] ，最大子段和为 0 ，因为没有任何子段存在。
所以，我们返回 [14,7,2,2,0] 。</pre>

<p><strong>示例 2：</strong></p>

<pre><b>输入：</b>nums = [3,2,11,1], removeQueries = [3,2,1,0]
<b>输出：</b>[16,5,3,0]
<b>解释：</b>用 0 表示被删除的元素，答案如下所示：
查询 1 ：删除第 3 个元素，nums 变成 [3,2,11,0] ，最大子段和为子段 [3,2,11] 的和 16 。
查询 2 ：删除第 2 个元素，nums 变成 [3,2,0,0] ，最大子段和为子段 [3,2] 的和 5 。
查询 3 ：删除第 1 个元素，nums 变成 [3,0,0,0] ，最大子段和为子段 [3] 的和 3 。
查询 5 ：删除第 0 个元素，nums 变成 [0,0,0,0] ，最大子段和为 0 ，因为没有任何子段存在。
所以，我们返回 [16,5,3,0] 。
</pre>

<p></p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>n == nums.length == removeQueries.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= removeQueries[i] &lt; n</code></li>
	<li><code>removeQueries</code>中所有数字 <strong>互不相同</strong>。</li>
</ul>

*/
 class Q420 {public static void main(String[] args) {}
static class Solution {
    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {

    }
}
}
