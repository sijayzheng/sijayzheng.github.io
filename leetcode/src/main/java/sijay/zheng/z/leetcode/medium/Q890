package sijay.zheng.z.leetcode.medium;
/**
 题目890：根据给定数字划分数组
<p>给你一个下标从 <strong>0</strong>开始的整数数组<code>nums</code>和一个整数<code>pivot</code>。请你将<code>nums</code>重新排列，使得以下条件均成立：</p>

<ul>
	<li>所有小于<code>pivot</code>的元素都出现在所有大于<code>pivot</code>的元素<strong>之前</strong>。</li>
	<li>所有等于<code>pivot</code>的元素都出现在小于和大于 <code>pivot</code>的元素 <strong>中间</strong>。</li>
	<li>小于 <code>pivot</code>的元素之间和大于 <code>pivot</code>的元素之间的 <strong>相对顺序</strong>不发生改变。
	<ul>
		<li>更正式的，考虑每一对<code>p<sub>i</sub></code>，<code>p<sub>j</sub></code>，<code>p<sub>i</sub></code>是初始时位置 <code>i</code>元素的新位置，<code>p<sub>j</sub></code>是初始时位置<code>j</code>元素的新位置。对于小于<code>pivot</code>的元素，如果<code>i &lt; j</code>且<code>nums[i] &lt; pivot</code> 和<code>nums[j] &lt; pivot</code>都成立，那么<code>p<sub>i</sub> &lt; p<sub>j</sub></code>也成立。类似的，对于大于<code>pivot</code>的元素，如果<code>i &lt; j</code> 且<code>nums[i] &gt; pivot</code> 和<code>nums[j] &gt; pivot</code>都成立，那么<code>p<sub>i</sub> &lt; p<sub>j</sub></code>。</li>
	</ul>
	</li>
</ul>

<p>请你返回重新排列 <code>nums</code>数组后的结果数组。</p>

<p></p>

<p><strong>示例 1：</strong></p>

<pre><b>输入：</b>nums = [9,12,5,10,14,3,10], pivot = 10
<b>输出：</b>[9,5,3,10,10,12,14]
<b>解释：</b>
元素 9 ，5 和 3 小于 pivot ，所以它们在数组的最左边。
元素 12 和 14 大于 pivot ，所以它们在数组的最右边。
小于 pivot 的元素的相对位置和大于 pivot 的元素的相对位置分别为 [9, 5, 3] 和 [12, 14] ，它们在结果数组中的相对顺序需要保留。
</pre>

<p><strong>示例 2：</strong></p>

<pre><b>输入：</b>nums = [-3,4,3,2], pivot = 2
<b>输出：</b>[-3,2,4,3]
<b>解释：</b>
元素 -3 小于 pivot ，所以在数组的最左边。
元素 4 和 3 大于 pivot ，所以它们在数组的最右边。
小于 pivot 的元素的相对位置和大于 pivot 的元素的相对位置分别为 [-3] 和 [4, 3] ，它们在结果数组中的相对顺序需要保留。
</pre>

<p></p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>6</sup> &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
	<li><code>pivot</code>等于<code>nums</code>中的一个元素。</li>
</ul>

*/
 class Q890 {public static void main(String[] args) {Solution solution=new Solution();}
static class Solution {
    public int[] pivotArray(int[] nums, int pivot) {

    }
}
}
