package sijay.zheng.z.leetcode.medium;
/**
 题目844：如果相邻两个颜色均相同则删除当前颜色
<p>总共有 <code>n</code>个颜色片段排成一列，每个颜色片段要么是<code>'A'</code>要么是<code>'B'</code>。给你一个长度为<code>n</code>的字符串<code>colors</code>，其中<code>colors[i]</code>表示第<code>i</code>个颜色片段的颜色。</p>

<p>Alice 和 Bob 在玩一个游戏，他们 <strong>轮流</strong>从这个字符串中删除颜色。Alice <strong>先手</strong>。</p>

<ul>
	<li>如果一个颜色片段为 <code>'A'</code>且 <strong>相邻两个颜色</strong>都是颜色 <code>'A'</code>，那么 Alice 可以删除该颜色片段。Alice<strong>不可以</strong>删除任何颜色<code>'B'</code>片段。</li>
	<li>如果一个颜色片段为 <code>'B'</code>且 <strong>相邻两个颜色</strong>都是颜色 <code>'B'</code>，那么 Bob 可以删除该颜色片段。Bob <strong>不可以</strong>删除任何颜色 <code>'A'</code>片段。</li>
	<li>Alice 和 Bob <strong>不能</strong>从字符串两端删除颜色片段。</li>
	<li>如果其中一人无法继续操作，则该玩家 <b>输</b>掉游戏且另一玩家 <strong>获胜</strong>。</li>
</ul>

<p>假设 Alice 和 Bob 都采用最优策略，如果 Alice 获胜，请返回<code>true</code>，否则 Bob 获胜，返回<em></em><code>false</code>。</p>

<p></p>

<p><strong>示例 1：</strong></p>

<pre><b>输入：</b>colors = "AAABABB"
<b>输出：</b>true
<b>解释：</b>
A<em><strong>A</strong></em>ABABB -&gt; AABABB
Alice 先操作。
她删除从左数第二个 'A' ，这也是唯一一个相邻颜色片段都是 'A' 的 'A' 。

现在轮到 Bob 操作。
Bob 无法执行任何操作，因为没有相邻位置都是 'B' 的颜色片段 'B' 。
因此，Alice 获胜，返回 true 。
</pre>

<p><strong>示例 2：</strong></p>

<pre><b>输入：</b>colors = "AA"
<b>输出：</b>false
<strong>解释：</strong>
Alice 先操作。
只有 2 个 'A' 且它们都在字符串的两端，所以她无法执行任何操作。
因此，Bob 获胜，返回 false 。
</pre>

<p><strong>示例 3：</strong></p>

<pre><b>输入：</b>colors = "ABBBBBBBAAA"
<b>输出：</b>false
<strong>解释：</strong>
ABBBBBBBA<em><strong>A</strong></em>A -&gt; ABBBBBBBAA
Alice 先操作。
她唯一的选择是删除从右数起第二个 'A' 。

ABBBB<strong><em>B</em></strong>BBAA -&gt; ABBBBBBAA
接下来轮到 Bob 操作。
他有许多选择，他可以选择任何一个 'B' 删除。

然后轮到 Alice 操作，她无法删除任何片段。
所以 Bob 获胜，返回 false 。
</pre>

<p></p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;=colors.length &lt;= 10<sup>5</sup></code></li>
	<li><code>colors</code>只包含字母<code>'A'</code>和<code>'B'</code></li>
</ul>

*/
 class Q844 {public static void main(String[] args) {Solution solution=new Solution();}
static class Solution {
    public boolean winnerOfGame(String colors) {

    }
}
}
