package sijay.zheng.z.leetcode.medium;
/**
 题目989：二的幂数组中查询范围内的乘积
<p>给你一个正整数<code>n</code>，你需要找到一个下标从<strong>0</strong>开始的数组<code>powers</code>，它包含 <strong>最少</strong>数目的 <code>2</code>的幂，且它们的和为<code>n</code>。<code>powers</code>数组是<strong>非递减</strong>顺序的。根据前面描述，构造<code>powers</code>数组的方法是唯一的。</p>

<p>同时给你一个下标从 <strong>0</strong>开始的二维整数数组<code>queries</code>，其中<code>queries[i] = [left<sub>i</sub>, right<sub>i</sub>]</code>，其中<code>queries[i]</code>表示请你求出满足<code>left<sub>i</sub> &lt;= j &lt;= right<sub>i</sub></code>的所有<code>powers[j]</code>的乘积。</p>

<p>请你返回一个数组<em></em><code>answers</code>，长度与<em></em><code>queries</code>的长度相同，其中<em></em><code>answers[i]</code>是第<em></em><code>i</code>个查询的答案。由于查询的结果可能非常大，请你将每个<code>answers[i]</code>都对<code>10<sup>9</sup> + 7</code><strong>取余</strong>。</p>

<p></p>

<p><strong>示例 1：</strong></p>

<pre><b>输入：</b>n = 15, queries = [[0,1],[2,2],[0,3]]
<b>输出：</b>[2,4,64]
<strong>解释：</strong>
对于 n = 15 ，得到 powers = [1,2,4,8] 。没法得到元素数目更少的数组。
第 1 个查询的答案：powers[0] * powers[1] = 1 * 2 = 2 。
第 2 个查询的答案：powers[2] = 4 。
第 3 个查询的答案：powers[0] * powers[1] * powers[2] * powers[3] = 1 * 2 * 4 * 8 = 64 。
每个答案对 10<sup>9</sup> + 7 得到的结果都相同，所以返回 [2,4,64] 。
</pre>

<p><strong>示例 2：</strong></p>

<pre><b>输入：</b>n = 2, queries = [[0,0]]
<b>输出：</b>[2]
<strong>解释：</strong>
对于 n = 2, powers = [2] 。
唯一一个查询的答案是 powers[0] = 2 。答案对 10<sup>9</sup> + 7 取余后结果相同，所以返回 [2] 。
</pre>

<p></p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt; powers.length</code></li>
</ul>

*/
 class Q989 {public static void main(String[] args) {Solution solution=new Solution();}
static class Solution {
    public int[] productQueries(int n, int[][] queries) {

    }
}
}
