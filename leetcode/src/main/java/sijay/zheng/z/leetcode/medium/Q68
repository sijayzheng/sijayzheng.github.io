package sijay.zheng.z.leetcode.medium;
/**
 题目68：有序链表转换二叉搜索树
<p>给定一个单链表的头节点 <code>head</code>，其中的元素 <strong>按升序排序</strong> ，将其转换为高度平衡的二叉搜索树。</p>

<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em>的左右两个子树的高度差不超过 1。</p>

<p></p>

<p><strong>示例 1:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2020/08/17/linked.jpg" style="height: 388px; width: 500px;" /></p>

<pre>
<strong>输入:</strong> head = [-10,-3,0,5,9]
<strong>输出:</strong> [0,-3,9,-10,null,5]
<strong>解释:</strong> 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。
</pre>

<p><strong>示例 2:</strong></p>

<pre>
<strong>输入:</strong> head = []
<strong>输出:</strong> []
</pre>

<p></p>

<p><strong>提示:</strong></p>

<ul>
	<li><code>head</code>中的节点数在<code>[0, 2 * 10<sup>4</sup>]</code>范围内</li>
	<li><code>-10<sup>5</sup>&lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>

*/
 class Q68 {public static void main(String[] args) {Solution solution=new Solution();}
//Definition for singly-linked list.
class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}
 *//Definition for a binary tree node.
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
 static class Solution {
    public TreeNode sortedListToBST(ListNode head) {

    }
}
}
