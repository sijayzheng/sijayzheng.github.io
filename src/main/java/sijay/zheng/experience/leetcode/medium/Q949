package sijay.zheng.experience.leetcode.medium;
/**
 题目949：裁剪数字后查询第 K 小的数字
<p>给你一个下标从 <strong>0</strong>开始的字符串数组<code>nums</code>，其中每个字符串 <strong>长度相等</strong>且只包含数字。</p>

<p>再给你一个下标从 <strong>0</strong>开始的二维整数数组<code>queries</code>，其中<code>queries[i] = [k<sub>i</sub>, trim<sub>i</sub>]</code>。对于每个<code>queries[i]</code>，你需要：</p>

<ul>
	<li>将<code>nums</code>中每个数字 <strong>裁剪</strong>到剩下 <strong>最右边</strong><code>trim<sub>i</sub></code>个数位。</li>
	<li>在裁剪过后的数字中，找到 <code>nums</code>中第<code>k<sub>i</sub></code>小数字对应的 <strong>下标</strong>。如果两个裁剪后数字一样大，那么下标 <strong>更小</strong>的数字视为更小的数字。</li>
	<li>将 <code>nums</code>中每个数字恢复到原本字符串。</li>
</ul>

<p>请你返回一个长度与 <code><span style="">queries</span></code>相等的数组<em></em><code>answer</code>，其中<em></em><code>answer[i]</code>是第<em></em><code>i</code><em></em>次查询的结果。</p>

<p><strong>提示：</strong></p>

<ul>
	<li>裁剪到剩下最右边 <code>x</code>个数位的意思是不断删除最左边的数位，直到剩下 <code>x</code>个数位。</li>
	<li><code>nums</code>中的字符串可能会有前导 0 。</li>
</ul>

<p></p>

<p><strong>示例 1：</strong></p>

<pre>
<b>输入：</b>nums = ["102","473","251","814"], queries = [[1,1],[2,3],[4,2],[1,2]]
<b>输出：</b>[2,2,1,0]
<strong>解释：</strong>
1. 裁剪到只剩 1 个数位后，nums = ["2","3","1","4"] 。最小的数字是 1 ，下标为 2 。
2. 裁剪到剩 3 个数位后，nums 没有变化。第 2 小的数字是 251 ，下标为 2 。
3. 裁剪到剩 2 个数位后，nums = ["02","73","51","14"] 。第 4 小的数字是 73 ，下标为 1 。
4. 裁剪到剩 2 个数位后，最小数字是 2 ，下标为 0 。
   注意，裁剪后数字 "02" 值为 2 。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<b>输入：</b>nums = ["24","37","96","04"], queries = [[2,1],[2,2]]
<b>输出：</b>[3,0]
<strong>解释：</strong>
1. 裁剪到剩 1 个数位，nums = ["4","7","6","4"] 。第 2 小的数字是 4 ，下标为 3 。
   有两个 4 ，下标为 0 的 4 视为小于下标为 3 的 4 。
2. 裁剪到剩 2 个数位，nums 不变。第二小的数字是 24 ，下标为 0 。
</pre>

<p></p>

<p><b>提示：</b></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>1 &lt;= nums[i].length &lt;= 100</code></li>
	<li><code>nums[i]</code> 只包含数字。</li>
	<li>所有<code>nums[i].length</code>的长度 <b>相同</b>。</li>
	<li><code>1 &lt;= queries.length &lt;= 100</code></li>
	<li><code>queries[i].length == 2</code></li>
	<li><code>1 &lt;= k<sub>i</sub> &lt;= nums.length</code></li>
	<li><code>1 &lt;= trim<sub>i</sub> &lt;= nums[0].length</code></li>
</ul>

<p></p>

<p><strong>进阶：</strong>你能使用 <strong>基数排序算法</strong> 解决此问题吗？这种解法的复杂度又是多少？</p>

*/
 class Q949 {public static void main(String[] args) {Solution solution=new Solution();}
static class Solution {
    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {

    }
}
}