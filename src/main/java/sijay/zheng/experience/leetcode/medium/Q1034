package sijay.zheng.experience.leetcode.medium;
/**
 题目1034：二进制矩阵中翻转最多一次使路径不连通
<p>给你一个下标从 <strong>0</strong>开始的<code>m x n</code><strong>二进制</strong> 矩阵<code>grid</code>。你可以从一个格子<code>(row, col)</code>移动到格子<code>(row + 1, col)</code>或者<code>(row, col + 1)</code>，前提是前往的格子值为 <code>1</code>。如果从<code>(0, 0)</code>到<code>(m - 1, n - 1)</code>没有任何路径，我们称该矩阵是<strong>不连通</strong>的。</p>

<p>你可以翻转 <strong>最多一个</strong>格子的值（也可以不翻转）。你 <strong>不能翻转</strong>格子<code>(0, 0)</code> 和<code>(m - 1, n - 1)</code>。</p>

<p>如果可以使矩阵不连通，请你返回<code>true</code>，否则返回<em></em><code>false</code><em></em>。</p>

<p><strong>注意</strong>，翻转一个格子的值，可以使它的值从<code>0</code>变<code>1</code>，或从<code>1</code>变<code>0</code>。</p>

<p></p>

<p><strong>示例 1：</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2022/12/07/yetgrid2drawio.png" style="width: 441px; height: 151px;" /></p>

<pre>
<b>输入：</b>grid = [[1,1,1],[1,0,0],[1,1,1]]
<strong>输出：</strong>true
<b>解释：</b>按照上图所示我们翻转蓝色格子里的值，翻转后从 (0, 0) 到 (2, 2) 没有路径。
</pre>

<p><strong>示例 2：</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2022/12/07/yetgrid3drawio.png" /></p>

<pre>
<b>输入：</b>grid = [[1,1,1],[1,0,1],[1,1,1]]
<b>输出：</b>false
<b>解释：</b>无法翻转至多一个格子，使 (0, 0) 到 (2, 2) 没有路径。
</pre>

<p></p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 1000</code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>grid[0][0] == grid[m - 1][n - 1] == 1</code></li>
</ul>

*/
 class Q1034 {public static void main(String[] args) {}
class Solution {
    public boolean isPossibleToCutPath(int[][] grid) {

    }
}
}